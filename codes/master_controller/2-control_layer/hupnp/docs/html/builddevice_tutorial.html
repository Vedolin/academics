<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Herqq: Tutorial for Building a UPnP Device</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Herqq</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Tutorial for Building a UPnP Device </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="settingup_descriptions"></a>
Setting up the device and service descriptions</h2>
<p>Generally, building a UPnP device with HUPnP involves two main steps in your part. First, you have to define a <em>UPnP</em> <em>device</em> <em>description</em> document following the specifications set by the UPnP forum. Depending of your UPnP Device Description document, you may need to define one or more <em>UPnP</em> <em>service</em> <em>description</em> documents as well. Second, you may have to implement a class for your device and most often one or more classes for each service your device contains.</p>
<p>For example, if you want to implement a standard UPnP device named <b>BinaryLight:1</b>, your device description could look something like this:</p>
<div class="fragment"><pre class="fragment"> &lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span>?&gt;
 &lt;root xmlns=<span class="stringliteral">&quot;urn:schemas-upnp-org:device-1-0&quot;</span>&gt;
     &lt;specVersion&gt;
         &lt;major&gt;1&lt;/major&gt;
         &lt;minor&gt;0&lt;/minor&gt;
     &lt;/specVersion&gt;
     &lt;device&gt;
         &lt;deviceType&gt;urn:schemas-upnp-org:device:BinaryLight:1&lt;/deviceType&gt;
         &lt;friendlyName&gt;UPnP Binary Light&lt;/friendlyName&gt;
         &lt;manufacturer&gt;MyCompany&lt;/manufacturer&gt;
         &lt;manufacturerURL&gt;www.mywebsite.org&lt;/manufacturerURL&gt;
         &lt;modelDescription&gt;New brilliant BinaryLight&lt;/modelDescription&gt;
         &lt;modelName&gt;SuperWhiteLight 4000&lt;/modelName&gt;
         &lt;modelNumber&gt;1&lt;/modelNumber&gt;
         &lt;UDN&gt;uuid:138d3934-4202-45d7-bf35-8b50b0208139&lt;/UDN&gt;
         &lt;serviceList&gt;
             &lt;service&gt;
                 &lt;serviceType&gt;urn:schemas-upnp-org:service:SwitchPower:1&lt;/serviceType&gt;
                 &lt;serviceId&gt;urn:upnp-org:serviceId:SwitchPower:1&lt;/serviceId&gt;
                 &lt;SCPDURL&gt;switchpower_scpd.xml&lt;/SCPDURL&gt;
                 &lt;controlURL&gt;/control&lt;/controlURL&gt;
                 &lt;eventSubURL&gt;/eventing&lt;/eventSubURL&gt;
             &lt;/service&gt;
         &lt;/serviceList&gt;
     &lt;/device&gt;
 &lt;/root&gt;
</pre></div><p>Note that the above is the standard device template for UPnP <b>BinaryLight:1</b> filled with imaginary information.</p>
<p>Since the <b>BinaryLight:1</b> defines a service, <b>SwitchPower:1</b>, you have to provide a service description document that could look like this:</p>
<div class="fragment"><pre class="fragment"> &lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span>?&gt;
 &lt;scpd xmlns=<span class="stringliteral">&quot;urn:schemas-upnp-org:service-1-0&quot;</span>&gt;
     &lt;specVersion&gt;
         &lt;major&gt;1&lt;/major&gt;
         &lt;minor&gt;0&lt;/minor&gt;
     &lt;/specVersion&gt;
     &lt;actionList&gt;
         &lt;action&gt;
             &lt;name&gt;SetTarget&lt;/name&gt;
             &lt;argumentList&gt;
                 &lt;argument&gt;
                     &lt;name&gt;newTargetValue&lt;/name&gt;
                     &lt;relatedStateVariable&gt;Target&lt;/relatedStateVariable&gt;
                     &lt;direction&gt;in&lt;/direction&gt;
                 &lt;/argument&gt;
             &lt;/argumentList&gt;
          &lt;/action&gt;
          &lt;action&gt;
              &lt;name&gt;GetTarget&lt;/name&gt;
              &lt;argumentList&gt;
                  &lt;argument&gt;
                      &lt;name&gt;RetTargetValue&lt;/name&gt;
                      &lt;relatedStateVariable&gt;Target&lt;/relatedStateVariable&gt;
                      &lt;direction&gt;out&lt;/direction&gt;
                  &lt;/argument&gt;
              &lt;/argumentList&gt;
          &lt;/action&gt;
          &lt;action&gt;
              &lt;name&gt;GetStatus&lt;/name&gt;
              &lt;argumentList&gt;
                  &lt;argument&gt;
                      &lt;name&gt;ResultStatus&lt;/name&gt;
                      &lt;relatedStateVariable&gt;Status&lt;/relatedStateVariable&gt;
                      &lt;direction&gt;out&lt;/direction&gt;
                  &lt;/argument&gt;
              &lt;/argumentList&gt;
          &lt;/action&gt;
      &lt;/actionList&gt;
      &lt;serviceStateTable&gt;
          &lt;stateVariable sendEvents=<span class="stringliteral">&quot;no&quot;</span>&gt;
              &lt;name&gt;Target&lt;/name&gt;
              &lt;dataType&gt;<span class="keywordtype">boolean</span>&lt;/dataType&gt;
              &lt;defaultValue&gt;0&lt;/defaultValue&gt;
          &lt;/stateVariable&gt;
          &lt;stateVariable sendEvents=<span class="stringliteral">&quot;yes&quot;</span>&gt;
              &lt;name&gt;Status&lt;/name&gt;
              &lt;dataType&gt;<span class="keywordtype">boolean</span>&lt;/dataType&gt;
              &lt;defaultValue&gt;0&lt;/defaultValue&gt;
          &lt;/stateVariable&gt;
      &lt;/serviceStateTable&gt;
 &lt;/scpd&gt;
</pre></div><p>The above description is the standard service description for the <b>SwitchPower:1</b> without any vendor specific declarations. For more information about description documents, see the UDA specification, sections 2.3 and 2.5.</p>
<h2><a class="anchor" id="creatingclasses"></a>
Creating the necessary HUPnP classes</h2>
<p>HUPnP doesn't require any classes to be created in order to "host" a UPnP device (make it visible for UPnP control points), but in order to plug in custom functionality you often have to accompany the device and service descriptions with corresponding classes.</p>
<p>In our example we have to derive a class we have to derive a class from <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">Herqq::Upnp::HServerService</a> for the <b>SwitchPower:1</b> service description and we <b>can</b> derive a class from <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">Herqq::Upnp::HServerDevice</a> for the <b>BinaryLight:1</b> device description. Note the last point, we do <b>not</b> have to create a class for the <b>BinaryLight:1</b>, but we can. Furthermore, if your service has no actions you do not need to create your own <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">HServerService</a> type either.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Omitting the creation of custom <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">HServerDevice</a> classes is common if there is no need to define a type that orchestrates the use, initialization and control of the contained services. Furthermore, such a type can specify information about the embedded devices and services that have to be present for the type to be initialized properly. And of course, it can offer features that are not present in the default <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">HServerDevice</a> class.</dd></dl>
<p>To create a custom <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">Herqq::Upnp::HServerDevice</a> you only need to derive from it. There are no abstract member functions to override, but there are a few virtual member functions that could be very useful to override in case you are writing a type for other people to use. For more information of this, see <a class="el" href="group__hupnp__devicemodel.html">Device Model</a>.</p>
<p>To create a concrete class from <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">Herqq::Upnp::HServerService</a> that exposes custom actions you can either:</p>
<ul>
<li>Override <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html#a4c4d1d19a5b7e052992cb99701a7153b" title="Creates and returns the &quot;action implementations&quot; of the actions the service exposes...">Herqq::Upnp::HServerService::createActionInvokes()</a>, which purpose is to create <em>callable entities</em> that will be called when the corresponding UPnP actions are invoked.</li>
<li>Define <code>Q_INVOKABLE</code> methods in your custom type derived from <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">HServerService</a> using the same method names as the action definitions in the service description document.</li>
</ul>
<p>The first option is much more flexible, as you have full control over what HUPnP should call when a particular action is invoked. In addition, callable entities aren't tied to member functions. The second option may be more convenient, as you don't have to implement <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html#a4c4d1d19a5b7e052992cb99701a7153b" title="Creates and returns the &quot;action implementations&quot; of the actions the service exposes...">HServerService::createActionInvokes()</a> and create the callable entities by yourself. Whichever option you choose, every action implementation has to have a signature of <code>action(const HActionArguments&amp;, HActionArguments*)</code> and <code>int</code> as a return type.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><ul>
<li>The UPnP actions of a particular UPnP service are defined in the service's description file and your service implementation has to implement all of them.</li>
<li>The callable entities are used internally by HUPnP. HUPnP does not otherwise expose them directly in the public API for action invocation.</li>
</ul>
</dd></dl>
<p>To continue with the example we will create two classes, one for the <b>BinaryLight:1</b> and one for the <b>SwitchPowerService:1</b>. Note, the class for the BinaryLight:1 is <b>not</b> required, but it is done here for demonstration purposes. Also note that for this example the class declarations are put into the same header file, although in real code you might want to separate them.</p>
<p><code>mybinarylight.h</code></p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;HUpnpCore/HServerDevice&gt;</span>
<span class="preprocessor"> #include &lt;HUpnpCore/HServerService&gt;</span>

 <span class="keyword">class </span>MyBinaryLightDevice :
    <span class="keyword">public</span> Herqq::Upnp::HServerDevice
 {

 <span class="keyword">public</span>:

    MyBinaryLightDevice();
    <span class="keyword">virtual</span> ~MyBinaryLightDevice();
 };

 <span class="keyword">class </span>MySwitchPowerService :
    <span class="keyword">public</span> Herqq::Upnp::HServerService
 {
 <span class="keyword">protected</span>:

     <span class="keyword">virtual</span> HActionInvokes createActionInvokes();

 <span class="keyword">public</span>:

     MySwitchPowerService();
     <span class="keyword">virtual</span> ~MySwitchPowerService();
 };
</pre></div><p>In turn, the implementation could look something like this:</p>
<p><code>mybinarylight.cpp</code></p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &quot;mybinarylight.h&quot;</span>

 <span class="keyword">using namespace </span>Herqq::Upnp;

 MyBinaryLightDevice::MyBinaryLightDevice()
 {
 }

 MyBinaryLightDevice::~MyBinaryLightDevice()
 {
 }

 MySwitchPowerService::MySwitchPowerService()
 {
 }

 MySwitchPowerService::~MySwitchPowerService()
 {
 }

 HServerServer::HActionInvokes MySwitchPowerService::createActionInvokes()
 {
     HActionInvokes retVal;
     <span class="keywordflow">return</span> retVal;
 }
</pre></div><p>Those who know UPnP and paid close attention to the above example might have noticed that something was off. Where are the actions?</p>
<p>According to the UPnP Device Architecture (UDA), a service may have zero or more actions. If a service has no actions, you don't have to create a custom <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">HServerService</a> derivative in the first place, but even if you do, similar class declaration and definition as shown above are enough.</p>
<p>However, the standard <b>BinaryLight:1</b> device type specifies the <b>SwitchPower:1</b> service type that has three actions defined (look back in the service description document). Namely these are <b>SetTarget</b>, <b>GetTarget</b> and <b>GetStatus</b>. To make the example complete the <code>MySwitchPowerService</code> class requires some additional work. Note that next example shows only one way of making the service complete. There are a few other ways, which will be discussed later in depth.</p>
<p>The complete declaration for <code>MySwitchPowerService</code>:</p>
<p><code>mybinarylight.h</code></p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;HUpnpCore/HServerService&gt;</span>

 <span class="keyword">class </span>MySwitchPowerService :
    <span class="keyword">public</span> Herqq::Upnp::HServerService
 {
 <span class="keyword">protected</span>:

     <span class="keyword">virtual</span> HActionInvokes createActionInvokes();

 <span class="keyword">public</span>:

     MySwitchPowerService();
     <span class="keyword">virtual</span> ~MySwitchPowerService();

     qint32 setTarget(
         <span class="keyword">const</span> <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>&amp; inArgs,
         <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>* outArgs);

     qint32 getTarget(
         <span class="keyword">const</span> <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>&amp; inArgs,
         <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>* outArgs);

     qint32 getStatus(
         <span class="keyword">const</span> <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>&amp; inArgs,
         <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>* outArgs);
 };
</pre></div><p>The complete definition for <code>MySwitchPowerService</code>:</p>
<p><code>mybinarylight.cpp</code></p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &quot;mybinarylight.h&quot;</span>

<span class="preprocessor"> #include &lt;HUpnpCore/HServerAction&gt;</span>
<span class="preprocessor"> #include &lt;HUpnpCore/HActionArguments&gt;</span>
<span class="preprocessor"> #include &lt;HUpnpCore/HServerStateVariable&gt;</span>

 MySwitchPowerService::MySwitchPowerService()
 {
 }

 MySwitchPowerService::~MySwitchPowerService()
 {
 }

 <a class="code" href="group__hupnp__devicemodel.html#gae2d7925bfcaa10d57cf5e1b912ac32aa" title="This is a type definition for a hash table containing HActionInvoke objects keyed with strings repres...">HServerService::HActionInvokes</a> MySwitchPowerService::createActionInvokes()
 {
     <a class="code" href="group__hupnp__devicemodel.html#gae2d7925bfcaa10d57cf5e1b912ac32aa" title="This is a type definition for a hash table containing HActionInvoke objects keyed with strings repres...">Herqq::Upnp::HServerService::HActionInvokes</a> retVal;

     retVal.insert(
         <span class="stringliteral">&quot;SetTarget&quot;</span>,
         <a class="code" href="group__hupnp__devicemodel.html#ga26b6814033e53dce72344a6ce73594f6" title="This is a type definition for a callable entity that is used for HServerAction invocation.">Herqq::Upnp::HActionInvoke</a>(<span class="keyword">this</span>, &amp;MySwitchPowerService::setTarget));

     <span class="comment">// The above lines map the MySwitchPowerService::setTarget() method to</span>
     <span class="comment">// the action that has the name SetTarget. In essence, this mapping instructs</span>
     <span class="comment">// HUPnP to call this method when the SetTarget action is invoked.</span>
     <span class="comment">// However, note that HActionInvoke accepts any &quot;callable entity&quot;,</span>
     <span class="comment">// such as a normal function or a functor. Furthermore, if you use a</span>
     <span class="comment">// method the method does not have to be public.</span>

     retVal.insert(
         <span class="stringliteral">&quot;GetTarget&quot;</span>,
         <a class="code" href="group__hupnp__devicemodel.html#ga26b6814033e53dce72344a6ce73594f6" title="This is a type definition for a callable entity that is used for HServerAction invocation.">Herqq::Upnp::HActionInvoke</a>(<span class="keyword">this</span>, &amp;MySwitchPowerService::getTarget));

     retVal.insert(
         <span class="stringliteral">&quot;GetStatus&quot;</span>,
         <a class="code" href="group__hupnp__devicemodel.html#ga26b6814033e53dce72344a6ce73594f6" title="This is a type definition for a callable entity that is used for HServerAction invocation.">Herqq::Upnp::HActionInvoke</a>(<span class="keyword">this</span>, &amp;MySwitchPowerService::getStatus));

     <span class="keywordflow">return</span> retVal;
 }

 qint32 MySwitchPowerService::setTarget(
     <span class="keyword">const</span> <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>&amp; inArgs, <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>* outArgs)
 {
     <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_argument.html" title="This is a class that represents an argument used in a UPnP action invocation.">Herqq::Upnp::HActionArgument</a> newTargetValueArg = inArgs.<a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html#a1646ae51621e12a31b2defe9dd0893d9" title="Returns an action argument with the specified name.">get</a>(<span class="stringliteral">&quot;newTargetValue&quot;</span>);
     <span class="keywordflow">if</span> (!newTargetValueArg.<a class="code" href="class_herqq_1_1_upnp_1_1_h_action_argument.html#aac1b70a2ed67ead038c4d3f5ac4d8a81" title="Indicates if the object is constructed with a proper name and a state variable.">isValid</a>())
     {
         <span class="comment">// If MySwitchPowerService class is not made for direct public use</span>
         <span class="comment">// this check is redundant, since in that case this method is called only by</span>
         <span class="comment">// HUPnP and HUPnP always ensures that the action arguments defined in the</span>
         <span class="comment">// service description are present when an action is invoked.</span>

         <span class="keywordflow">return</span> <a class="code" href="namespace_herqq_1_1_upnp.html#a1a251130a462e694a9e3b59f64b61e6da7a9f30c3fba2acccf2afac1710cbf59c" title="Action invocation failed due to:">Herqq::Upnp::UpnpInvalidArgs</a>;
     }

     <span class="keywordtype">bool</span> newTargetValue = newTargetValueArg.<a class="code" href="class_herqq_1_1_upnp_1_1_h_action_argument.html#a12941b94e8268bc37c41e163a793155f" title="Returns the value of the argument.">value</a>().toBool();
     stateVariables().value(<span class="stringliteral">&quot;Target&quot;</span>)-&gt;setValue(newTargetValue);

     <span class="comment">// The above line modifies the state variable &quot;Target&quot;, which reflects the</span>
     <span class="comment">// &quot;target state&quot; of a light device, i.e. if a user wants to turn off a light, the</span>
     <span class="comment">// &quot;target state&quot; is the light turned off whether the light can be turned</span>
     <span class="comment">// off or not.</span>

     <span class="comment">//</span>
     <span class="comment">// Do here whatever that is required to turn on / off the light</span>
     <span class="comment">// (set it to the target state)</span>
     <span class="comment">//</span>

     <span class="comment">//</span>
     <span class="comment">// If it succeeded, we should modify the Status state variable to reflect</span>
     <span class="comment">// the new state of the light.</span>
     <span class="comment">//</span>

     stateVariables().value(<span class="stringliteral">&quot;Status&quot;</span>)-&gt;setValue(newTargetValue);

     <span class="keywordflow">return</span> <a class="code" href="namespace_herqq_1_1_upnp.html#a1a251130a462e694a9e3b59f64b61e6da1499768a87e0ffded6fa679f945a5023">Herqq::Upnp::UpnpSuccess</a>;
 }

 qint32 MySwitchPowerService::getTarget(
     <span class="keyword">const</span> <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>&amp; inArgs, <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>* outArgs)
 {
     <span class="keywordflow">if</span> (!outArgs)
     {
         <span class="comment">// See the comments in MySwitchPowerService::setTarget why this</span>
         <span class="comment">// check is here. Basically, this check is redundant if this method</span>
         <span class="comment">// is called only by HUPnP, as HUPnP ensures proper arguments</span>
         <span class="comment">// are always provided when an action is invoked.</span>

         <span class="keywordflow">return</span> <a class="code" href="namespace_herqq_1_1_upnp.html#a1a251130a462e694a9e3b59f64b61e6da7a9f30c3fba2acccf2afac1710cbf59c" title="Action invocation failed due to:">Herqq::Upnp::UpnpInvalidArgs</a>;
     }

     <span class="keywordtype">bool</span> b = stateVariables().value(<span class="stringliteral">&quot;Target&quot;</span>)-&gt;value().toBool();
     outArgs-&gt;<a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html#ac0a3a95d808cce192c5a24184e4f45ca" title="Attempts to set the value of the specified state variable.">setValue</a>(<span class="stringliteral">&quot;RetTargetValue&quot;</span>, b);

     <span class="keywordflow">return</span> <a class="code" href="namespace_herqq_1_1_upnp.html#a1a251130a462e694a9e3b59f64b61e6da1499768a87e0ffded6fa679f945a5023">Herqq::Upnp::UpnpSuccess</a>;
 }

 qint32 MySwitchPowerService::getStatus(
     <span class="keyword">const</span> <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>&amp; inArgs, <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>* outArgs)
 {
     <span class="keywordflow">if</span> (!outArgs)
     {
         <span class="comment">// See the comments in MySwitchPowerService::getTarget();</span>
         <span class="keywordflow">return</span> <a class="code" href="namespace_herqq_1_1_upnp.html#a1a251130a462e694a9e3b59f64b61e6da7a9f30c3fba2acccf2afac1710cbf59c" title="Action invocation failed due to:">UpnpInvalidArgs</a>;
     }

     <span class="keywordtype">bool</span> b = stateVariables().value(<span class="stringliteral">&quot;Status&quot;</span>)-&gt;value().toBool();
     outArgs-&gt;<a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html#ac0a3a95d808cce192c5a24184e4f45ca" title="Attempts to set the value of the specified state variable.">setValue</a>(<span class="stringliteral">&quot;ResultStatus&quot;</span>, b);

     <span class="keywordflow">return</span> <a class="code" href="namespace_herqq_1_1_upnp.html#a1a251130a462e694a9e3b59f64b61e6da1499768a87e0ffded6fa679f945a5023">Herqq::Upnp::UpnpSuccess</a>;
 }
</pre></div><p>The above example overrode the <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html#a4c4d1d19a5b7e052992cb99701a7153b" title="Creates and returns the &quot;action implementations&quot; of the actions the service exposes...">HServerService::createActionInvokes()</a> and did the action name - callable entity mapping. However, if you'd rather have HUPnP do that automatically, you can mark your action implementations as <code>Q_INVOKABLE</code> as follows:</p>
<p><code>mybinarylight.h</code></p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;HUpnpCore/HServerService&gt;</span>

 <span class="keyword">class </span>MySwitchPowerService :
    <span class="keyword">public</span> Herqq::Upnp::HServerService
 {
 Q_OBJECT

 <span class="keyword">public</span>:

     MySwitchPowerService();
     <span class="keyword">virtual</span> ~MySwitchPowerService();

     Q_INVOKABLE qint32 SetTarget(
         <span class="keyword">const</span> <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>&amp; inArgs,
         <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>* outArgs);

     Q_INVOKABLE qint32 GetTarget(
         <span class="keyword">const</span> <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>&amp; inArgs,
         <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>* outArgs);

     Q_INVOKABLE qint32 GetStatus(
         <span class="keyword">const</span> <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>&amp; inArgs,
         <a class="code" href="class_herqq_1_1_upnp_1_1_h_action_arguments.html" title="A storage class for HActionArgument instances.">Herqq::Upnp::HActionArguments</a>* outArgs);
 };
</pre></div><p>Apart from changing the method names to start with capital letters, the method definitions stay otherwise the same.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Using <code>Q_INVOKABLE</code> methods as action implementations you have to ensure that the names of the member functions correspond <b>exactly</b> to the action names defined in the service description document.</dd></dl>
<h3><a class="anchor" id="some_notes_about_switchpower_example"></a>
Some closing notes</h3>
<p>First of all, you may want to skim the discussion in <a class="el" href="group__hupnp__devicemodel.html">Device Model</a> and <a class="el" href="group__hupnp__devicehosting.html">Device Hosting</a> to fully understand the comments in the example above. Especially the section <a class="el" href="setting_up_the_devicemodel.html">Setting Up the Device Model</a> is useful if you want to learn the details of building a custom UPnP device using HUPnP. That being said, perhaps the most important issues of building a custom UPnP device using HUPnP can be summarized to:</p>
<ul>
<li>Every device description has to have a corresponding <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">Herqq::Upnp::HServerDevice</a> and every service description has to have a corresponding <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">Herqq::Upnp::HServerService</a>. However, you don't have to create a custom <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">HServerDevice</a>, in which case HUPnP will create and use a default <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">HServerDevice</a> type. In addition, if a service has no actions you don't have to create a custom <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">HServerService</a>. On the other hand, most commonly a service has one or more actions, so this is something you'll be doing often.</li>
</ul>
<ul>
<li>It is perfectly fine to create custom <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">HServerDevice</a> and <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">HServerService</a> classes just to be hosted in a <a class="el" href="class_herqq_1_1_upnp_1_1_h_device_host.html" title="This is a class for creating and hosting HServerDevice instances on the network.">Herqq::Upnp::HDeviceHost</a>. Such classes exist only to run your code when UPnP control points interact with them over the network. These types of classes are to be used directly only by <a class="el" href="class_herqq_1_1_upnp_1_1_h_device_host.html" title="This is a class for creating and hosting HServerDevice instances on the network.">HDeviceHost</a>.</li>
</ul>
<ul>
<li>You can create more advanced <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">HServerDevice</a> and <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">HServerService</a> classes perhaps to build a higher level public API or just to provide yourself a nicer interface for doing something. This was the case with <code>MySwitchPowerService</code> class, which extended the <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">HServerService</a> interface by providing the possibility of invoking the actions of the service through the <code>setTarget()</code>, <code>getTarget()</code> and <code>getStatus()</code> methods.</li>
</ul>
<ul>
<li>HUPnP allows direct (in-process) access to the hosted <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">HServerDevice</a> and <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">HServerService</a> classes, which means you can interact with your classes <b>while</b> they are being hosted and possibly used from external processes. Custom <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">HServerDevice</a> and <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">HServerService</a> interfaces may be beneficial in such a case.</li>
</ul>
<ul>
<li>The type behind an Herqq::Upnp::HActionInvoke can hold any <em>callable entity</em>, such as a pointer to a normal function, functor or a pointer to a member function.</li>
</ul>
<ul>
<li>A public callable entity should always strictly verify the input and respond to illegal input accordingly. A "private" callable entity that is called only by HUPnP can rest assured that HUPnP never passes a null input argument or an argument that has an incorrect name or data type.</li>
</ul>
<ul>
<li>Before implementing your own device and service types directly from <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">HServerDevice</a> and <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_service.html" title="This is an abstract base class for server-side UPnP services.">HServerService</a>, you should check if HUPnP provides more refined classes to suit your requirements. For instance, HUPnP provides a base class Herqq::Upnp::Lighting::HAbstractSwitchPower for simplifying the implementation and use of <b>SwitchPower:1</b>.</li>
</ul>
<p>In any case, the above example demonstrates a fully standard-compliant implementation of <b>BinaryLight:1</b>. The next step is to publish your <a class="el" href="class_herqq_1_1_upnp_1_1_h_server_device.html" title="This is an abstract base class for server-side UPnP devices hosted by HDeviceHost.">HServerDevice</a> in the network for UPnP control points to discover. You can find the instructions for that in <a class="el" href="class_herqq_1_1_upnp_1_1_h_device_host.html" title="This is a class for creating and hosting HServerDevice instances on the network.">HDeviceHost</a> and <a class="el" href="group__hupnp__devicehosting.html">Device Hosting</a>. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Mar 28 2011 00:45:38 for Herqq by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
